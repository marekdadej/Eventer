@model IEnumerable<Eventer.Models.Event>

@{
    ViewData["Title"] = "Moje Zapisane Wydarzenia";
}

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<style>
    :root {
        --ev-yellow: #ffc107;
        --ev-dark: #222;
        --ev-grey: #333;
        --ev-text: #eee;
    }

    body {
        background-color: var(--ev-grey);
        color: var(--ev-text);
        font-family: sans-serif;
        margin: 0;
        padding-bottom: 50px;
    }

    .container {
        max-width: 1920px;
        margin: 0 auto;
        padding: 20px;
    }

    h2 {
        color: var(--ev-yellow);
        border-bottom: 1px solid #555;
        padding-bottom: 15px;
        margin-bottom: 20px;
        text-transform: uppercase;
    }

    /* GRID */
    .events-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 25px;
    }

    .event-card {
        background-color: var(--ev-dark);
        border: 1px solid #444;
        border-radius: 8px;
        overflow: hidden;
        transition: transform 0.3s ease, border-color 0.3s ease;
    }

    .event-card:hover {
        transform: translateY(-5px);
        border-color: var(--ev-yellow);
        box-shadow: 0 10px 20px rgba(0,0,0,0.5);
    }

    .card-img-wrap {
        height: 200px;
        width: 100%;
        background-color: #000;
        position: relative;
        cursor: pointer;
        overflow: hidden;
    }

    .card-img-wrap img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: opacity 0.3s;
    }

    .card-img-wrap:hover img {
        opacity: 0.3;
    }

    .view-btn {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--ev-yellow);
        color: #000;
        font-weight: bold;
        padding: 10px 20px;
        border-radius: 4px;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
    }

    .card-img-wrap:hover .view-btn {
        opacity: 1;
    }

    .card-body {
        padding: 15px;
    }

    .card-title {
        font-size: 1.2rem;
        font-weight: bold;
        color: #fff;
        margin-bottom: 5px;
    }

    .card-date {
        color: var(--ev-yellow);
        font-size: 0.9rem;
        margin-bottom: 10px;
    }

    .card-details {
        font-size: 0.85rem;
        color: #bbb;
        line-height: 1.5;
    }

    /* MODAL 3D */
    .modal-overlay {
        display: none;
        position: fixed;
        z-index: 2000;
        left: 0; top: 0;
        width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.95);
        justify-content: center; align-items: center;
    }

    .modal-content-3d {
        width: 90%;
        height: 85%;
        background: #222;
        border: 2px solid var(--ev-yellow);
        position: relative;
        box-shadow: 0 0 50px rgba(255, 193, 7, 0.2);
    }

    .close-modal {
        position: absolute;
        top: 15px;
        right: 30px;
        color: #fff;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        z-index: 2001;
    }
    .close-modal:hover { color: var(--ev-yellow); }

    #viewer3D {
        width: 100%;
        height: 100%;
        display: block;
    }
    
    .loading-info {
        position: absolute; bottom: 20px; left: 20px;
        color: #aaa; font-size: 0.9rem; background: rgba(0,0,0,0.7);
        padding: 5px 10px; pointer-events: none;
    }
</style>

<div class="container">
    <h2>Twoje zapisane wydarzenia</h2>
    <p style="color:#aaa; margin-bottom: 30px;">
        Kliknij w projekt, aby otworzyÄ‡ interaktywnÄ… wizualizacjÄ™ 3D.
    </p>

    <div class="events-grid">
        @if (Model != null && Model.Any())
        {
            foreach (var item in Model)
            {
                <div class="event-card">
                    <div class="card-img-wrap" onclick='openModal(@Json.Serialize(item))'>
                        @if (!string.IsNullOrEmpty(item.ImageUrl))
                        {
                            <img src="@item.ImageUrl" alt="Wizualizacja" />
                        }
                        else
                        {
                            <div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; color:#555;">Brak PodglÄ…du</div>
                        }
                        <div class="view-btn">OTWÃ“RZ 3D â†»</div>
                    </div>

                    <div class="card-body">
                        <div class="card-title">@item.Name</div>
                        <div class="card-date">
                            ðŸ“… @item.CreatedDate.ToString("dd.MM.yyyy") <span style="color:#666">|</span> ðŸ•’ @item.CreatedDate.ToString("HH:mm")
                        </div>
                        <div class="card-details">
                            Typ: <strong style="color:#fff">@item.MainType?.ToUpper()</strong><br/>
                            System: @(item.RoofSystem ?? "-")
                        </div>
                    </div>
                </div>
            }
        }
        else
        {
            <div style="grid-column: 1/-1; text-align:center; padding: 50px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                <h3 style="color:#bbb">Brak zapisanych projektÃ³w.</h3>
                <a href="/Events/Create" class="btn" style="background-color:var(--ev-yellow); color:#000; font-weight:bold; padding:10px 20px; text-decoration:none; margin-top:15px; display:inline-block; border-radius:4px;">StwÃ³rz nowy projekt</a>
            </div>
        }
    </div>
</div>

<div id="vizModal" class="modal-overlay">
    <span class="close-modal" onclick="closeModal()">&times;</span>
    <div class="modal-content-3d">
        <div id="viewer3D"></div>
        <div class="loading-info">Tryb podglÄ…du interaktywnego</div>
    </div>
</div>

<script>
    // === ZMIENNE GLOBALNE ===
    let scene, camera, renderer, controls, animationId;
    let mainGroup;
    const MOD = 2.07;
    const MOD_HALF = 1.04;

    // === OBSÅUGA MODALA ===
    function openModal(data) {
        const modal = document.getElementById('vizModal');
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden'; // Zablokuj scrollowanie strony

        // Inicjalizacja Three.js (jeÅ›li jeszcze nie ma)
        init3D();
        
        // Zbudowanie sceny na podstawie danych z bazy
        rebuildSavedScene(data);
    }

    function closeModal() {
        const modal = document.getElementById('vizModal');
        modal.style.display = 'none';
        document.body.style.overflow = 'auto'; // Odblokuj scrollowanie
        
        // Zatrzymaj animacjÄ™ (oszczÄ™dnoÅ›Ä‡ GPU)
        if (animationId) cancelAnimationFrame(animationId);
        
        // WyczyÅ›Ä‡ scenÄ™
        if (mainGroup) {
            while(mainGroup.children.length > 0) mainGroup.remove(mainGroup.children[0]);
        }
    }

    // ObsÅ‚uga ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === "Escape") closeModal();
    });

    // === THREE.JS SETUP ===
    function init3D() {
        const container = document.getElementById('viewer3D');
        
        // JeÅ›li renderer juÅ¼ jest, tylko wznÃ³w animacjÄ™
        if (renderer) {
            animate();
            return;
        }

        let w = container.clientWidth;
        let h = container.clientHeight;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333); 
        scene.fog = new THREE.Fog(0x333333, 20, 200);

        camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
        camera.position.set(40, 30, 50);
        camera.lookAt(0, 5, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(w, h);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // OÅ›wietlenie
        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffc107, 0.9);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Siatka
        const grid = new THREE.GridHelper(100, 50, 0x555555, 0x444444);
        scene.add(grid);

        mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // Resize
        window.addEventListener('resize', () => {
            if (container && renderer) {
                const newW = container.clientWidth;
                const newH = container.clientHeight;
                renderer.setSize(newW, newH);
                camera.aspect = newW / newH;
                camera.updateProjectionMatrix();
            }
        });

        animate();
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    // === LOGIKA ODTWARZANIA SCENY (To samo co w Create) ===
    function rebuildSavedScene(d) {
        if (!mainGroup) return;
        
        // CzyÅ›Ä‡
        while(mainGroup.children.length > 0) mainGroup.remove(mainGroup.children[0]);

        // =======================
        // ODTWARZANIE SCENY
        // =======================
        
        if (d.mainType === 'stage') {
            const sW = d.stageWidth || 12.42;
            const sD = d.stageDepth || 10.35;
            const sH = d.stageHeight || 1.5;
            const roofH = sH + (d.clearance || 9.0);

            // 1. PodÅ‚oga i konstrukcja
            mainGroup.add(createFloor(sW, sD, sH));
            mainGroup.add(createLayherStructure(sW, sD, sH, 0, 0, 0, 0x555555));

            // 2. Siatki (Scrim) - Odczytujemy boolean HasScrim
            if (d.hasScrim && d.roofSystem !== 'none') {
                const sm = new THREE.MeshBasicMaterial({color:0x000000, opacity:0.8, transparent:true, side:THREE.DoubleSide});
                let backH = roofH;
                if (d.roofSystem === 'layher') backH = sH + 2.5;

                const bm = new THREE.Mesh(new THREE.PlaneGeometry(sW, backH-sH), sm);
                bm.position.set(0, (backH+sH)/2, -sD/2);
                mainGroup.add(bm);

                if (d.roofSystem === 'layher') {
                    const shape = new THREE.Shape();
                    shape.moveTo(-sD/2, sH); shape.lineTo(sD/2, sH); shape.lineTo(sD/2, sH+3); shape.lineTo(-sD/2, sH+2.5);
                    const sg = new THREE.ShapeGeometry(shape);
                    const sl = new THREE.Mesh(sg, sm); sl.rotation.y = -Math.PI/2; sl.position.set(-sW/2, 0, 0); mainGroup.add(sl);
                    const sr = sl.clone(); sr.rotation.y = -Math.PI/2; sr.position.set(sW/2, 0, 0); mainGroup.add(sr);
                } else {
                    const sl = new THREE.Mesh(new THREE.PlaneGeometry(sD, roofH-sH), sm);
                    sl.rotation.y = Math.PI/2; sl.position.set(-sW/2, (roofH+sH)/2, 0); mainGroup.add(sl);
                    const sr = sl.clone(); sr.position.set(sW/2, (roofH+sH)/2, 0); mainGroup.add(sr);
                }
            }

            // 3. Dach
            if (d.roofSystem !== 'none') {
                const roofGroup = new THREE.Group();
                const matTruss = new THREE.MeshStandardMaterial({color: (d.roofSystem==='prolyte'?0x999999:0x111111), wireframe:true});

                if (d.roofSystem === 'layher') {
                    const hF=3.0; const hB=2.5;
                    const pF = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,hF), new THREE.MeshStandardMaterial({color:0x999999}));
                    const pB = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,hB), new THREE.MeshStandardMaterial({color:0x999999}));
                    [-sW/2, sW/2].forEach(x => {
                        let f = pF.clone(); f.scale.y=(sH+hF)/hF; f.position.set(x,(sH+hF)/2,sD/2); roofGroup.add(f);
                        let b = pB.clone(); b.scale.y=(sH+hB)/hB; b.position.set(x,(sH+hB)/2,-sD/2); roofGroup.add(b);
                    });
                    const g = new THREE.BufferGeometry();
                    const v = new Float32Array([ -sW/2,sH+hF,sD/2, sW/2,sH+hF,sD/2, -sW/2,sH+hB,-sD/2, sW/2,sH+hF,sD/2, sW/2,sH+hB,-sD/2, -sW/2,sH+hB,-sD/2 ]);
                    g.setAttribute('position', new THREE.BufferAttribute(v,3)); g.computeVertexNormals();
                    roofGroup.add(new THREE.Mesh(g, new THREE.MeshStandardMaterial({color:0x111111, side:THREE.DoubleSide})));
                } else {
                    const isBig = (d.roofSystem==='alustage' && sW>18);
                    const scaff = createGroundSupport(sW, sD, roofH); 
                    mainGroup.add(scaff);

                    if (d.roofSystem === 'prolyte') {
                        const roof = createGableRoofMesh(sW+1, sD+1, 2.5, 0x888888);
                        roof.position.y = roofH; roofGroup.add(roof);
                    } else { // alustage
                        const roof = createCustomRoofMesh(sW+0.5, sD+0.5, 3.5, sD/2 - 7.0, 0x111111, 1.0);
                        roof.position.y = roofH; roofGroup.add(roof);
                    }
                }
                mainGroup.add(roofGroup);
            }

            // 4. Wingi
            if (d.wingWidthBays > 0 && d.roofSystem !== 'layher') {
                const wW = d.wingWidthBays * MOD;
                const wD = d.wingDepthBays * MOD;
                const off = sW/2 + wW/2;
                const wz = sD/2 - wD/2;

                mainGroup.add(createLayherStructure(wW, wD, roofH, -off, 0, wz, 0x999999));
                mainGroup.add(createLayherStructure(wW, wD, roofH, off, 0, wz, 0x999999));

                if (d.wingType === 'scrim') {
                    const sm = new THREE.MeshBasicMaterial({color:0x000000, opacity:0.8, transparent:true, side:THREE.DoubleSide});
                    const sl = new THREE.Mesh(new THREE.PlaneGeometry(wW, roofH), sm);
                    sl.position.set(-off, roofH/2, wz+wD/2+0.05); mainGroup.add(sl);
                    const sr = sl.clone(); sr.position.set(off, roofH/2, wz+wD/2+0.05); mainGroup.add(sr);
                }
            }

            // 5. FOH
            if (d.fohLevel > 0 && d.roofSystem !== 'layher') {
                let fw = 4.14, fd = 4.14;
                if(d.fohSize) { const p = d.fohSize.split('|'); fw=parseFloat(p[0]); fd=parseFloat(p[1]); }
                
                const fDist = d.fohDist || 20;
                const fz = sD/2 + fDist + fd/2;
                const floors = d.fohLevel;

                mainGroup.add(createFloor(fw, fd, 0.4));
                mainGroup.add(createLayherStructure(fw, fd, (floors===2 ? 2.5 : 0.4), 0, 0, fz, 0x999999));
                if(floors === 2) {
                    const fl2 = createFloor(fw, fd, 2.5); fl2.position.z = fz; mainGroup.add(fl2);
                }

                const topH = (floors===2 ? 2.5 : 0.4);
                const g = new THREE.BufferGeometry();
                const v = new Float32Array([-fw/2,topH+3,fz-fd/2, fw/2,topH+3,fz-fd/2, -fw/2,topH+2.5,fz+fd/2, fw/2,topH+3,fz-fd/2, fw/2,topH+2.5,fz+fd/2, -fw/2,topH+2.5,fz+fd/2]);
                g.setAttribute('position', new THREE.BufferAttribute(v,3)); g.computeVertexNormals();
                mainGroup.add(new THREE.Mesh(g, new THREE.MeshStandardMaterial({color:0x111111, side:THREE.DoubleSide})));

                if (d.fohScrim) {
                    const sm = new THREE.MeshBasicMaterial({color:0x000000, opacity:0.8, transparent:true, side:THREE.DoubleSide});
                    const floorY = 0.4;
                    // TyÅ‚
                    const bh = (topH+2.5)-floorY;
                    const b = new THREE.Mesh(new THREE.PlaneGeometry(fw, bh), sm);
                    b.position.set(0, floorY + bh/2, fz+fd/2); mainGroup.add(b);
                    // Boki
                    const sh = new THREE.Shape(); sh.moveTo(-fd/2, floorY); sh.lineTo(fd/2, floorY); sh.lineTo(fd/2, topH+2.5); sh.lineTo(-fd/2, topH+3.0);
                    const sg = new THREE.ShapeGeometry(sh);
                    const s1 = new THREE.Mesh(sg, sm); s1.rotation.y=-Math.PI/2; s1.position.set(-fw/2,0,fz); mainGroup.add(s1);
                    const s2 = new THREE.Mesh(sg, sm); s2.rotation.y=-Math.PI/2; s2.position.set(fw/2,0,fz); mainGroup.add(s2);
                }

                if (d.fohTower === 'tower') {
                    const th = 8.0; // DomyÅ›lna wys
                    const tW = 4.14; // DomyÅ›lna szer
                    const tz = fz + fd/2 + 1.04;
                    mainGroup.add(createLayherStructure(tW, 2.07, th, 0, 0, tz, 0xbbbbbb));
                }
            }

        } else if (d.mainType === 'tower') {
            const tw = (d.towerWidthBays || 1) * 2.07;
            const td = d.towerDepth || 2.07;
            const th = d.towerHeight || 8.0;
            mainGroup.add(createLayherStructure(tw, td, th, 0, 0, 0, 0xbbbbbb));

        } else if (d.mainType === 'wall') {
            // wallW_bays mapujemy na TowerWidthBays w bazie
            const ww = (d.towerWidthBays || 1) * MOD; 
            const wd = 2.07;
            // wallH_bays mapujemy na TowerHeight w bazie
            const wh = d.towerHeight || 8.0;
            mainGroup.add(createLayherStructure(ww, wd, wh, 0, 0, 0, 0xbbbbbb));
        }
    }

    // --- FUNKCJE BUILDERÃ“W (Kopie z Create.cshtml) ---
    function createLayherStructure(width, depth, height, x, y, z, color) {
        const grp = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ color: color, metalness: 0.4, roughness: 0.6 });
        
        let stepX = MOD; if (width < 2.1) stepX = width;
        let stepZ = MOD; if (depth < 2.1) stepZ = depth;
        const cX = Math.round(width / stepX); const cZ = Math.round(depth / stepZ);
        
        const geoP = new THREE.CylinderGeometry(0.04, 0.04, height, 8);
        for(let i=0; i<=cX; i++) for(let j=0; j<=cZ; j++) {
            const p = new THREE.Mesh(geoP, mat);
            p.position.set(i*(width/cX)-width/2, height/2, j*(depth/cZ)-depth/2);
            grp.add(p);
        }
        
        const levs = Math.floor(height/2);
        const geoL = new THREE.CylinderGeometry(0.02, 0.02, 1);
        for(let l=1; l<=levs; l++) {
            let ly = l*2.0;
            for(let j=0; j<=cZ; j++) for(let i=0; i<cX; i++) {
                const b = new THREE.Mesh(geoL, mat); b.scale.y=width/cX; b.rotation.z=Math.PI/2;
                b.position.set(i*(width/cX)-width/2+(width/cX)/2, ly, j*(depth/cZ)-depth/2); grp.add(b);
            }
            for(let i=0; i<=cX; i++) for(let j=0; j<cZ; j++) {
                const b = new THREE.Mesh(geoL, mat); b.scale.y=depth/cZ; b.rotation.x=Math.PI/2;
                b.position.set(i*(width/cX)-width/2, ly, j*(depth/cZ)-depth/2+(depth/cZ)/2); grp.add(b);
            }
        }
        grp.position.set(x,y,z); return grp;
    }

    function createFloor(w,d,h) {
        const m = new THREE.Mesh(new THREE.BoxGeometry(w, 0.05, d), new THREE.MeshStandardMaterial({color:0x222}));
        m.position.y = h; return m;
    }

    function createGroundSupport(stageW, stageD, totalHeight) {
        const group = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({color: 0x999999});
        const geoP = new THREE.CylinderGeometry(0.04, 0.04, totalHeight, 8);
        const geoL = new THREE.CylinderGeometry(0.02, 0.02, MOD);
        
        const addTower = (tx, tz) => {
            const t = new THREE.Group();
            const pos = [[-MOD/2,-MOD/2], [MOD/2,-MOD/2], [-MOD/2,MOD/2], [MOD/2,MOD/2]];
            pos.forEach(p => { const pole = new THREE.Mesh(geoP, mat); pole.position.set(p[0], totalHeight/2, p[1]); t.add(pole); });
            for(let h=2; h<totalHeight; h+=2) {
                const l1=new THREE.Mesh(geoL, mat); l1.rotation.z=Math.PI/2; l1.position.set(0, h, -MOD/2); t.add(l1);
                const l2=new THREE.Mesh(geoL, mat); l2.rotation.z=Math.PI/2; l2.position.set(0, h, MOD/2); t.add(l2);
                const l3=new THREE.Mesh(geoL, mat); l3.rotation.x=Math.PI/2; l3.position.set(-MOD/2, h, 0); t.add(l3);
                const l4=new THREE.Mesh(geoL, mat); l4.rotation.x=Math.PI/2; l4.position.set(MOD/2, h, 0); t.add(l4);
            }
            t.position.set(tx, 0, tz); group.add(t);
        };

        const xOff = stageW/2 + MOD/2;
        const zStart = -stageD/2 + MOD/2;
        const sideC = Math.floor(stageD/MOD);
        const backC = Math.floor(stageW/MOD);

        for(let i=0; i<sideC; i++) { let z = zStart + i*MOD; addTower(-xOff, z); addTower(xOff, z); }
        const zBack = -stageD/2 - MOD/2; const xStart = -stageW/2 + MOD/2;
        for(let i=0; i<backC; i++) { addTower(xStart + i*MOD, zBack); }
        addTower(-xOff, zBack); addTower(xOff, zBack);
        return group;
    }

    function createCustomRoofMesh(width, depth, peakHeight, peakZPos, color, opacity) {
        const geo = new THREE.BufferGeometry();
        const hw=width/2; const fz=depth/2; const bz=-depth/2; const pz=peakZPos; const ph=peakHeight;
        const v = new Float32Array([-hw,0,fz, hw,0,fz, -hw,ph,pz, hw,0,fz, hw,ph,pz, -hw,ph,pz, -hw,ph,pz, hw,ph,pz, -hw,0,bz, hw,ph,pz, hw,0,bz, -hw,0,bz, -hw,0,bz, -hw,ph,pz, -hw,0,fz, hw,0,fz, hw,ph,pz, hw,0,bz]);
        geo.setAttribute('position', new THREE.BufferAttribute(v,3)); geo.computeVertexNormals();
        return new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:color, side:THREE.DoubleSide, opacity:opacity, transparent:opacity<1.0, roughness:0.3}));
    }

    function createGableRoofMesh(width, depth, peakH, color) { 
        const geo = new THREE.BufferGeometry();
        const hw=width/2; const hd=depth/2;
        const v = new Float32Array([-hw,0,hd, -hw,0,-hd, 0,peakH,-hd, -hw,0,hd, 0,peakH,-hd, 0,peakH,hd, hw,0,hd, 0,peakH,hd, 0,peakH,-hd, hw,0,hd, 0,peakH,-hd, hw,0,-hd, -hw,0,hd, hw,0,hd, 0,peakH,hd, -hw,0,-hd, 0,peakH,-hd, hw,0,-hd]);
        geo.setAttribute('position', new THREE.BufferAttribute(v,3)); geo.computeVertexNormals();
        return new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:color, side:THREE.DoubleSide}));
    }
</script>